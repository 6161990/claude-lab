# Cursor Project Rules: AI로 요건정의부터 구현까지 올라운드 패키지

(c)2025 JAEWOO, KIM. All Rights Reserved.

## 이 자료를 만든 이유

Cursor에 2100시간 이상 접한 경험을 가진 AI코딩 개발자로서 매일 4시간 이상 Cursor와 사투끝에 제품 개발을 극복한 경험을 강의를 듣는 분들에게 공유하기 위해 만든 자료입니다.

"Accept 연타 → 수수께끼 코드 → 오류 지옥"의 무한 반복에서 벗어나는 방법을 소개하고 실제 실무 개발 현장에서 만들어낸 생성형 AI 코드 정리방법을 공유합니다.

## 왜 개발 프로세스의 체계화가 필요한가?

개인개발이나 팀 개발에 있어서 다음과 같은 문제에 직면하고 있지 않습니까?

- **코드 품질 편차**: 개발자에 따라 다른 코딩스타일과 명명 규칙
- **설계에서 구현까지 일관성이 없음**: 요구사항 정의는 만들었지만 구현시 마주함
- **프로토타입과 프로덕션 환경 간의 격차**: 프로토타입은 실행되지만, 프로독션 마이그레이션에서 많은 문제가 발생함
- **AI 도구 활용시 지시의 모호함**: 커서에게 의뢰하지만 예상대로 결과를 얻을 수 없음
- **품질 보증 속인화**: 테스트와 리뷰는 개인의 경험에 의존함
- **실패로 인한 학습 부족**: 유사한 오류와 문제를 반복함

이러한 문제를 해결하기 위해 내가 실제 프로젝트에서 사용하고 효과를 느끼는 14개의 통합 개발 프로세스 프롬프트 를 자세히 설명합니다.

이번에 공개하는 프롬프트는 요구사항 정의부터 프로덕션 운용, 지속적인 개선에 이르기까지 전 공정을 커버하고 있으며, 커서와 조합함으로써 개발 효율을 극적으로 향상시킬 수 있습니다.

이번에 공개하는 프롬프트는 요구사항 정의부터 구현, 테스트, 디버깅에 이르는 모든 공정을 다루고 있으며, 커서와 결합하여 개발 효율을 극적으로 향상시킬 수 있습니다.

이런 규칙을 만들 기 전에 에러를 Cursor에서 먼저 실행해도 에러의 반복때문에 고생하던 시간들이 이 방법을 도입하게 되면서 오류해결시간이 짧아졌습니다. 이유는 자신이 만든 코드를 AI와 함께 만들어 가기 때문에 "이 Cursor의 에러는 조금 나의 의도하고 있는 부분이 다르겠지?"라고 생각하기 때문입니다. 


## 전체 기술 스택

## 프론트엔드 기술

### 프레임워크 라이브러리 

- Next.js 14+ (App Router)
- React (Hooks 지원)
- TypeScript
- shadcn/ui + Radix UI
- Tailwind CSS

### 상태 관리 · API 연계

- React Context API 또는 Redux
- 커스텀 후크 (useState, useEffect, useCallback 등)
- HTTP 클라이언트 (fetch, axios 등)

### 테스트 및 개발 툴

- Jest
- React Testing Library
- Cypress 또는 Playwright
- ESLint
- Prettier
 
## 백엔드 기술

### 프레임워크/언어

- 파이썬 3.8+
- FastAPI
- Pydantic (데이터 검증)
- SQLAlchemy (ORM)

### 데이터베이스

- PostgreSQL
- SQLite(개발 환경)

### 테스트 및 품질 관리

- pytest
- pytest-mock
- TestContainers
- httpx(테스트용 HTTP 클라이언트)

## 개발 환경 및 도구

### 편집기 IDE

- Cursor 또는 Visual Studio Code 
- Live Server 확장
- Playwright MCP(브라우저 자동화)

### 버전관리, CI/CD

- Git
- GitHub
- CI/CD 파이프라인 설정

## 인프라 배포

### 컨테이너 오케스트레이션

- Docker
- Docker Compose

## API, 통합

### API 설계 및 문서화

- OpenAPI (Swagger) 3.0+
- RESTful API 설계 원칙
- JSON 스키마

### 외부 서비스 통합

- 외부 API 연동
- Webhook 대응
- 인증 및 허가 (OAuth, JWT)

## 설계 및 아키텍처

### 설계 기법

- 4+1 뷰 모델
- Mermaid 도표 작성
- ADR (Architecture Decision Records)
- 마이크로서비스 설계(옵션)

## UI/UX 디자인

### 디자인 툴 연계

- Figma API 연계
- HTML to Figma 변환
- 반응형 디자인

### 프레젠테이션

- Marp (Markdown 프레젠테이션)
- PowerPoint (.pptx) 변환
- LibreOffice (soffice 명령)

이 내용들은 어디까지나 시스템 프롬프트에 넣는 내용이므로, "자신의 기술스택을 입력하고 이에 맞게 최적화 해주세요."와 Cursor에게 요청하면 고쳐줍니다.  

## Cursor Rules: 14개 개발 프로세스 프롬프트

## 설계단계 (5단계)

- doc01-requirements.mdc: 요구사항정의, 사용자 요구 사항 분석 및 구성 과 질문 생성
- doc02-adr.mdc: 아키텍처 결정 기록, 기술 선택 기록 및 이유
- doc03-database.mdc 데이터베이스 설계, 데이터베이스 설계 및 ER 다이어그램, 테이블 정의
- doc04-api-spec.mdc API 사양, RESTful API 사양 자동 생성
- doc05-ui-concept-prototype.mdc UI 개념 프로토타입, 초기 단계에서 UI 개념 설계 및 클라이언트 합의 형성

## 상세설계 및 검토 단계 (2단계)

- doc06-detailed-design.mdc 상세 설계, 시스템 상세 사양 작성 (4+1 뷰 모델)
- doc07-design-review-procedure.mdc 설계검토, 상세 설계 이해도 체크・품질 개선 제안

## 분석 및 계획단계 (2단계)

- doc08_prototype_analysis.mdc 프로토타입 분석, 프로토타입의 프로덕션 적성 평가 및 갭 분석
- doc09-implementation-plan.mdc 구현계획, 프로덕션 개발 구현 계획 작성 및 단계적 전략 수립

## 구현 및 테스트 단계(2단계)

- doc10-implementation-generation.mdc 구현생성, 상세설계서·API 사양서로부터 코드 생성
- doc11-test-generation.mdc 테스트생성, 구현 코드에서 레이어드 테스트 생성

## 품질보증 및 개선단계(3단계)

- doc12-quality-assurance-validation.mdc 품질 보증 및 검증, 구현 및 테스트 계획의 품질 보증 자동화
- doc13-debug.mdc 디버그, 최종 목적 역산 사고 오류 처리 및 학습 지원
- doc14-ai-task-failure-analysis.mdc AI 실패분석, AI 작업의 체계적 분석 및 지속적인 개선

### doc01-requirements.mdc: 요구사항정의 프롬프트

- 목적: 사용자의 모호한 요청을 구체적이고 구현가능한 요구사항으로 변환하고 부족한 정보를 파악하여 적절한 질문을 생성합니다.
- 도입 고려사항: 중요한 것은 Cursor를 사용하여 개발하는 사용자는 내 환경에서 인프라와 기술에 반드시 밝지 않은 사용자가 많다고 생각됩니다. 따라서 사용자는 어떤 기술을 사용하면 구현이 완료되는지 위험이 있는지 모르는 상태라고 가정합니다. Cursor로부터 질문을 받으면서 기능과 비기능 요건을 진행시키기 위한 도움을 받도록 구성했습니다.
- 사용예시

```terminal
@doc01-requirements.mdc를 사용하여 다음 요구 사항을 분석하십시오.
"이커머스 사이트의 사용자 관리 기능을 만들고 싶다. 로그인, 신규 등록, 프로필 편집을 할 수 있도록 하고 싶다."
```

### doc02-adr.mdc: 아키텍처 결정 기록 프롬프트

- 목적: 기술선택의 근거를 명확히 하고 향후 개발팀이 판단 배경을 이해할 수 있는 아키텍처 결정 기록을 작성합니다.
- 도입 고려사항: '리스크가 있는 것을 사전에 전한 후에 작성을 진행하는 것'을 추가해서 사용자측에도 손쉽게 ADR을 작성하는 기회를 줄이는 이해를 요구하는 것을 추가했습니다.
- 사용예시

```terminal
@doc-02-adr.mdc를 사용하여 작업 관리 웹 앱의 아키텍처를 결정합니다.

요구사항:
- 팀을 위한 작업 관리
- 실시간 업데이트
- 50명 정도 동시 이용
- 3개월 만에 출시 예정
```

### doc03-database.mdc: 데이터베이스 설계

- 목적: ADR에서 결정된 데이터베이스 기술을 기반으로 정규화된 데이터베이스 설계와 ER 다이어그램, 테이블 정의를 작성합니다.
- 도입 고려사항: 데이터베이스 설계는 나중에 구현할 때 큰 영향을 미치므로 다음과 같은 아이디어를 도입했습니다.

1. 단계별 설계접근법 (개념설계 → 논리적 설계 → 물리적 설계)
2. 정규화와 성능의 균형을 중시
3. 미래의 확장성을 고려한 설계
중요한 부분은 데이터베이스 설계는 시스템의 기반이 되므로 변경비용이 높습니다.

### doc04-api-spec.mdc: API 사양 프롬프트 

- 목적: 일관된 RESTful API 스펙을 OpenAPI 형식으로 작성하여 개발 팀의 커뮤니케이션을 원활하게 합니다.
- 도입 고려사항: 백엔드와 프런트 엔드의 연결의 간이 되는 API 부분도 개별적으로 작성을 하고 있습니다.
어떤 정보를 전달하는지 정확하게 기재하면 백엔드와 프런트 엔드의 구현 담당자를 나누어 병렬로 작업을 할 수도 있습니다.
- 응답

```terminal
성공 응답: {HTTP 상태 코드}
{
  "property1": "value1",
  "property2": "value2"
}
```

- 사용예시

```terminal
curl -X POST https://api.example.com/endpoint \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer token" \
  -d '{"property": "value"}'
```

### doc05-ui-concept-prototype.mdc: UI개념 프로토타입  

- 목적: UI 개념 프로토타입, 데이터베이스 설계, API 사양을 기반으로 구현 가능한 UI 컴포넌트와 디자인 시스템을 작성합니다.
- 도입 고려사항: svelte라는 경량의 js 프레임워크를 사용해 간이적으로 화면을 작성해, 거기로부터 적절히 vibe coding적으로 수정을 더해 작성하도록 했습니다. 이 때 확장 기능 중 하나 인 stagewise(https://stagewise.io/)를 사용합니다.
이 확장 기능을 통해 한번에 수정할 수 있고 최종적으로 작성한 UI를 기반으로 FIGMA와 연결해서 클라이언트와 적절히 화면UI합의를 도모하는 단계라고 봅니다. 
- 응답

```terminal
성공 응답: {HTTP 상태 코드}
{
  "property1": "value1",
  "property2": "value2"
}
```

- 사용예시

```terminal
curl -X POST https://api.example.com/endpoint \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer token" \
  -d '{"property": "value"}'
```

### doc06-detailed-design.mdc: 상세설계 프로토타입  

- 목적: ADR을 바탕으로 구현 수준의 구체적인 설계서를 작성해, 불명점은 반드시 질문해 명확화하고 나서 설계서를 완성시킵니다.
- 도입 고려사항: 이 단계에서 정의된 내용은 이후의 실제 구현으로 넘어가면서 변경/수정 시 전체 일정에 영향을 줄 수 있으며, 손쉬운 수정이 어려워질 수 있습니다. 따라서 이 시점에서 사용자 측에서도 기능과 화면 흐름에 대한 이해를 충분히 갖추고 있어야 하며, 의도된 사용 방식과 기대 결과에 대한 확실한 합의가 필요합니다.
- 사용예시

```terminal
@doc06-detailed-design.mdc를 사용하여 작업 관리 앱에 대한 상세한 디자인을 만듭니다.

ADR 내용:
- 프런트엔드: Next.js + TypeScript
- 백엔드: FastAPI + Python
- 데이터베이스: PostgreSQL
- 주요 기능: 작업 생성, 편집, 삭제, 상태 관리
```

- 생성된 질문 

```terminal
상세 설계를 작성하기 전에 다음 사항을 명확히하십시오.

## 기능 요구 사항에 대해 자세히 알아보기
1. **태스크 데이터 구조**: 태스크에는 어떤 속성이 필요합니까? 
- 필수 항목 : 제목, 설명, 작성일시 
- 옵션 항목 : 기한, 우선 순위, 담당자, 카테고리 등

2. **상태 관리**: 상태 유형 및 전환 규칙을 알려주세요. 
- 예 : 미착수 → 진행 중 → 완료 → 아카이브

3. **권한 관리**: 사용자 인증이 필요합니까?여러 사용자의 작업 공유는?

## 비기능 요구사항
1. **성능**: 예상 동시 사용자 수, 응답 시간 요구 사항
2. **데이터 보존**: 작업 삭제는 논리 삭제입니까?

이 정보를 알려주세요.
```

### @doc07-design-review-procedure.mdc: 상세설계 프로토타입  

- 목적: 상세 설계에 대해 사용자의 이해도를 확인하고 부적절한 부분이 있으면 단계적으로 해설하여 이해를 깊게 합니다.
- 도입 고려사항: 여기는 의도적으로 휴먼 인더 루프를 돌리는 설계로 하고 있습니다.
- 사용예시

```terminal
@doc07-design-review-procedure.mdc를 사용하여 이커머스 사이트의 제품 관리 시스템 설계를 검토하십시오.

디자인 개요:
- 상품 등록, 편집, 삭제 기능
- 재고 관리 기능
- 카테고리 분류 기능
- 검색 및 필터링 기능
```

### @doc08-prototype-analysis.mdc: 상세설계 프로토타입  

- 목적: '프로토타입은 실행되지만, 프로덕션에서 사용할 수 있을까?'이 근본적인 의문을 해결하기 위해서 개발된 프롬프트입니다.
많은 개발자가 경험하는 "프로토타입 완성 → 만일 프로덕션 이행 → 대량의 문제 발견"이라고 하는 악몽의 사이클을 차단합니다. 완성한 프로토타입을 3개의 페이즈로 체계적으로 분석해, 프로덕션 환경에서 요구되는 품질 레벨과의 갭을 명확화합니다.
- 도입 고려사항:

1. 단계적 분석접근방식

- 1단계: 프로토타입 코드 이해 - 우선 현재의 프로토타입 코드가 어떤 구조와 흐름을 가지고 있는지 객관적으로 파악합니다. 감정이나 선입견 없이, 코드가 실제로 무엇을 하고 있는지를 정확히 분석합니다.
- 2단계: 본番 적합성 평가 - 이 프로토타입이 실제 운영환경(본番, production)에서 사용할 수 있는 수준인지 검토합니다. 구조적 안정성, 보안, 성능, 장애 대응력 등을 기준으로 평가합니다.
- 3단계: 차이 인식 및 명확화 - 프로토타입과 본番 구현 사이에서 필요한 변경점(기능 보완, 성능 개선, 예외 처리 등)을 정리하고, 어떤 부분을 어디까지 바꿔야 할지 명확히 합니다. 차이(diff)의 구조화를 통해 구체적인 구현 계획으로 연결됩니다.

 ✅ 이 구조는 분석 과정에서 감정이나 주관을 배제하고, 객관적인 기술적 관찰을 바탕으로 논리적 개선 전략을 수립하는 데 효과적입니다.

2. 5가지 품질 축(Quality Axes)에 따른 평가 기준

다음의 5가지 축을 기준으로, 프로토타입의 품질을 다각도로 평가합니다:

- 보안(Security)

  - 인증(Authentication) 및 권한 제어(Authorization)
  - 민감 데이터 보호 및 암호화
  - OWASP 기반의 취약점 대응

- 성능(Performance)
  
  - API 응답 시간 및 처리 속도
  - 부하 분산 및 스케일링 가능성
  - CPU/메모리/네트워크 사용 효율

- 가용성(Availability)

  - 에러 처리 전략
  - 장애 감지 및 모니터링
  - 자동 복구(failover) 및 재시작 메커니즘

- 유지보수성(Maintainability)
  
  - 코드 일관성, 리팩토링 용이성
  - 단위 테스트 및 통합 테스트
  - README/설정/설계 문서 등 문서화 수준

- 운영성(Operability)
  - CI/CD 환경 및 배포 자동화
  - 로그 수집 및 에러 추적 체계
  - 서비스 상태 모니터링 및 메트릭 관리

1. 체크리스트 기반 누락 방지 시스템

- 기술 스택 구성 분석
- 보완이 필요한 기능 목록화
- 위험요소 확인 및 라벨링
- 대응 우선순위 분류
- 개발/리뷰/배포 등 각 단계별 진행 상황 체크
  
✅ 체크박스 형태로 시각화하여, 실무 팀 내에서 누락 없이 체계적으로 점검하고 공유할 수 있도록 구성합니다.

1. 리스크 기반 개선 우선순위 설정
우선순위를 단순히 주관적으로 정하지 않고, 아래 3가지 평가 축을 활용해 객관적이고 전략적인 분류를 진행합니다:

- 영향도(Impact): 이슈가 실제 시스템에 미치는 영향의 크기
- 발생 가능성(Probability): 문제가 얼마나 자주 혹은 쉽게 발생할 수 있는지
- 수정 비용(Effort): 해당 이슈를 해결하기 위한 시간 및 리소스

예를 들어, 영향도는 높지만 발생 확률이 낮고, 수정 비용이 낮은 경우 ‘단기 우선 대응 항목’으로 분류될 수 있습니다.
✅ 이 방식은 기술적 리스크를 현실적인 개발 전략과 연결하는 데 유용합니다. 단기/중기/장기 우선순위를 명확히 나누어 계획을 수립할 수 있습니다.

- 사용예시
  
```terminal
@doc08-prototype-analysis.mdc를 사용하여 다음 프로토타입을 분석해 주세요.

"Next.js + Supabase로 개발한 파일 공유 애플리케이션의 프로토타입이 완성되었습니다.
사용자 인증, 파일 업로드, 공유 기능은 동작하고 있지만,
운영 환경(본환경)에서의 운용을 고려하면 불안한 점이 있습니다. 분석을 부탁드립니다."
```

### @doc09-implementation-plan.mdc: 프로덕션 개발 구현 계획 작성 가이드  

- 목적: "프로토타입 분석 결과를 어떻게 구현 계획에 빠뜨릴 것인가?" 이 과제를 해결하는 프롬프트입니다.
프로토타입 분석에서 명확해진 격차를 바탕으로 프로덕션 환경을 위한 단계적인 구현 계획을 책정합니다.

- 도입 고려사항: 

1. 5단계의 계획 수립 프로세스
Phase 1: 전제조건 확인 → Phase 2: 구현 전략 수립 → Phase 3: 상세 구현 계획
→ Phase 4: 위험 관리 계획 → Phase 5: 품질 보증 계획
2. 체크리스트 구동의 확실성
각 단계에서 필요한 확인 사항을 체크 박스 형식으로 제시하여 계획 누락을 방지
3. 3축에서의 우선순위 결정

- 필수도 : 프로덕션 운영에 필수적입니까?
- 위험도 : 구현하지 않을 경우의 영향도
- 종속성 : 다른 기능에 미치는 영향 정도

4. 현실적인 공수 견적

낙관적 견적을 피하고 버퍼를 포함한 현실적인 스케줄링

- 사용예시

```terminal
@doc09-implementation-plan.mdc를 사용하여 다음 구현 계획을 수립하십시오.

“프로토타입 분석 결과 보안 강화와 성능 개선이 필요하다는 것이 밝혀졌습니다.
상세 설계서도 완성되어 있어, 2주간에서의 프로덕션 이행을 목표로 하고 싶습니다.
현실적인 구현 계획을 수립하십시오."
```

### @doc10-implementation-generation.mdc: 프로덕션 개발 구현 계획 작성 가이드  

- 목적: 구현 분석 → 기능별 구현 계획 수립 → 레벨별 구현 생성 의 단계적 접근 방식을 통해 3단계 구현 전략을 프런트 엔드와 백엔드 모두에서 구현하고 전체 스택 시스템의 품질을 단계적으로 향상시키는 것을 목표로 합니다.

- 도입 고려사항: 

프로토타입과 구현 계획서에서 3단계의 단계에서 작성하는 프롬프트를 작성하고 있습니다.

### @doc11-test-generation.mdc: 테스트 생성 프롬프트  

- 목적: 구현 분석 → 기능별 테스트 계획 수립 → 레벨별 테스트 생성 의 단계적 접근 방식을 통해 3단계 테스트 전략을 프런트 엔드와 백엔드 모두에서 구현하고 전체 스택 시스템의 품질을 단계적으로 보장하는 것을 목표로 합니다.

- 도입 고려사항: 

이것은 doc10의 구현과 세트가 되는 부분입니다.

단계별 구현과 테스트를 병행하여 구현할 수 있는 내용으로 하고 있습니다.

### @doc12-quality-assurance-validation.mdc: 품질 보증 및 검증 시스템  

- 목적: "디자인서와 구현 계획, 테스트 계획의 무결성은 잡혀 있을까?" 이 중요한 의문을 자동화에 의해 해결하는 프롬프트입니다.
인간의 검토에서는 간과하기 쉬운 설계서에서 누락이나 계획서 간의 부정합을 단계적 검증 프로세스로 조기 발견·수정합니다. 개발을 시작하기 전에 품질을 담보하고 후퇴를 최소화합니다.

- 도입 고려사항:
 
1. 3단계 검증 프레임워크
Phase 1: 설계서→실장 계획서 검증 → Phase 2: 실장 계획서→테스트 계획서 검증 → Phase 3: 종합 무결성 검증
2. 자동 검증 규칙 구현
Python 코드를 통한 자동 검사 기능으로 인적 실수 제거
3. 품질 게이트 기준의 명확화

```bash
quality_gates:
  phase1_pass_criteria:
    structural_consistency: ">= 95%"
    functional_coverage: ">= 90%"
    technical_alignment: ">= 85%"
    critical_issues: "0件"
```
4. 개선제안 자동생성
문제 발견뿐만 아니라 구체적인 수정 방법과 공수 견적까지 제시