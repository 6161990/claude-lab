---
description:
globs:
alwaysApply: false
---
# 프로토타입 기반 단계적 구현 생성 규칙

## 1. 프로젝트 개요

### 1.1 구현 전략의 기본 방침
본 계획서는 **구현 분석 → 기능별 구현 계획 수립 → 레벨별 구현 생성**의 단계적 접근 방식을 통해 프론트엔드 및 백엔드 모두에서 3단계 구현 전략을 수행하여, 풀스택 시스템의 품질을 점진적으로 향상시키는 것을 목표로 합니다.

### 1.2 실행 단계 개요
```mermaid
graph TD
    A[Phase 0: 시스템 분석] --> B[Phase 1: 구현 계획 수립]
    B --> C[Phase 2: 레벨 선택 및 구현 생성]
    C --> D[Phase 3: 구현 실행 및 품질 검증]
    
    A --> A1[구현 코드 분석]
    A --> A2[기획서 분석]
    A --> A3[API 사양 분석]
    A --> A4[DB 설계 분석]
    
    B --> B1[기능별 구현 대상 정리]
    B --> B2[레벨별 구현 계획]
    B --> B3[사용자 확인 및 선택]
    
    C --> C1[선택된 레벨의 구현 생성]
    C --> C2[구현 환경 준비]
    
    D --> D1[구현 실행]
    D --> D2[품질 검증 및 보고서 작성]
```

### 1.3 구현 피라미드 구성 (개정판)
```
        Level 3 E2E구현 (10%)
    ─────────────────────────────────
      Frontend E2E | Backend E2E
   Level 2 통합 구현 (20%)
  ───────────────────────────────────
   Frontend통합 | Backend통합
 Level 1 유닛/모킹 구현 (70%)
────────────────────────────────────────
Frontend Unit   |   Backend Unit
```

## 2. 구현 레벨 정의 (프론트엔드 / 백엔드 대응)

### 2.1 Level 1: 유닛 / 모킹(mock) 기반 구현

#### 2.1.1 Backend Level 1
- **목적**: 비즈니스 로직 단위의 유닛 구현
- **신뢰도**: 60-70%
- **구현 빈도**: 커밋 시마다
- **구현 시간**: 분 단위
- **기술 스택**: FastAPI, Pydantic, unittest.mock
- **대상 범위**: 
  - 순수 함수, 계산 로직
  - API 핸들러 (의존성 모킹 포함)
  - 서비스 클래스 메서드
  - 유효성 검사 함수

#### 2.1.2 Frontend Level 1  
- **목적**: 컴포넌트 단위 유닛 구현
- **신뢰도**: 60-70%
- **구현 빈도**: 커밋 시마다
- **구현 시간**: 분 단위
- **기술 스택**: Next.js, React, TypeScript, Tailwind CSS
- **대상 범위**:
  - 개별 UI 컴포넌트
  - Props 처리 로직
  - 이벤트 핸들러
  - 커스텀 훅 (hooks)

### 2.2 Level 2: 통합 구현

#### 2.2.1 Backend Level 2
- **목적**: 기능 간 통합 및 연계 구현
- **신뢰도**: 75-85%
- **구현 빈도**: 주 단위
- **구현 시간**: 시간 단위
- **기술 스택**: FastAPI, Supabase, PostgreSQL
- **대상 범위**:
  - API와 DB 연동 처리
  - 서비스 간 연동 처리
  - 외부 API 연동 (개발 환경 기준)
  - 트랜잭션 처리 및 롤백 테스트

#### 2.2.2 Frontend Level 2
- **목적**: 다중 컴포넌트 및 API 통합 구현
- **신뢰도**: 75-85%
- **구현 빈도**: 주 단위
- **実装時間**: 시간 단위
- **기술 스택**: Next.js, Zustand, API통합
- **대상 범위**:
  - 컴포넌트 간 상호작용
  - API 호출 처리
  - 상태 관리 구현 (예: Zustand)
  - 라우팅 처리 (Next.js 기준)

### 2.3 Level 3: E2E구현

#### 2.3.1 Backend Level 3
- **목적**: 전체 플로우 기반 백엔드 기능 구현
- **신뢰도**: 90-95%
- **구현 빈도**: 릴리스 직전
- **구현 시간**: 일 단위
- **기술 스택**: FastAPI, 실제 스테이징 환경 서비스
- **대상 범위**:
  - API를 통한 전체 흐름 검증
  - 실제 배포 환경과 유사한 조건에서 테스트
  - 성능 튜닝 (쿼리 최적화 등)
  - 보안 기능 포함 (인증, 권한, 데이터 보호)

#### 2.3.2 Frontend Level 3
- **목적**: 사용자 플로우 전체 구현 (로그인 → 대시보드 등)
- **신뢰도**: 90-95%
- **구현 빈도**: 릴리스 직전
- **구현 시간**: 일 단위
- **기술 스택**: Next.js, 스테이징 환경 통합
- **대상 범위**:
  - 실제 사용자 여정을 반영한 전체 플로우
  - 크로스 브라우저 대응
  - 접근성(Accessibility) 기준 충족
  - 반응형 디자인 최적화

## 3. 구현 환경 구성

### 3.1 Level 1 구현 환경

#### Backend Level 1
```yaml
backend_level1:
  name: "Backend Mock Environment"
  database: "In-memory SQLite"
  external_services: "All Mocked"
  storage: "Mock Storage"
  setup_time: "< 1분"
  cleanup: "자동"
```

#### Frontend Level 1
```yaml
frontend_level1:
  name: "Frontend Unit Environment"
  browser: "Development Mode"
  api_services: "All Mocked"
  components: "Isolated Implementation"
  setup_time: "< 1분"
  cleanup: "자동"
```

### 3.2 Level 2 구현 환경

#### Backend Level 2
```yaml
backend_level2:
  name: "Backend Integration Environment"
  database: "Development PostgreSQL"
  external_services: "Development Services"
  storage: "Development Bucket"
  setup_time: "10-30분"
  cleanup: "자동 + 수동 확인"
```

#### Frontend Level 2
```yaml
frontend_level2:
  name: "Frontend Integration Environment"
  browser: "Development Mode"
  api_services: "Development Backend"
  components: "Multi-component Implementation"
  state_management: "Real Store"
  setup_time: "5-15분"
  cleanup: "자동"
```

### 3.3 Level 3 구현 환경

#### Backend Level 3
```yaml
backend_level3:
  name: "Backend E2E Environment"
  database: "Staging Database"
  external_services: "Staging Services"
  storage: "Staging Bucket"
  setup_time: "1-5시간"
  cleanup: "수동 확인 필수"
```

#### Frontend Level 3
```yaml
frontend_level3:
  name: "Frontend E2E Environment"
  browser: "Production-like Environment"
  api_services: "Staging Backend"
  environment: "Full Application"
  setup_time: "30분-2시간"
  cleanup: "자동 + 산출물 보존"
```

## 4. Phase 0: 시스템 분석 및 구현 계획 수립

### 4.1 구현 분석 단계

#### 4.1.1 분석 대상 문서
```yaml
required_documents:
  implementation:
    - backend_source_code: "API 구현, 서비스, 모델"
    - frontend_source_code: "컴포넌트, 페이지, 훅"
    - database_schema: "테이블 정의 및 관계"
  
  specifications:
    - api_specification: "OpenAPI/Swagger사양"
    - database_design: "ERD, 제약 조건 정의"
    - system_design: "아키텍처 설계서"
    - user_requirements: "요구사항 정의서"
  
  optional_documents:
    - deployment_config: "인프라 설정"
    - security_requirements: "보안 요구사항"
    - performance_requirements: "성능 요구사항"
```

#### 4.1.2 자동 분석 프로세스
```python
class SystemImplementationAnalyzer:
    def analyze_system(self, documents):
        """시스템 전반을 분석하고 구현 대상을 식별"""
        analysis_result = {
            "backend_features": self._analyze_backend_implementation(documents),
            "frontend_features": self._analyze_frontend_implementation(documents),
            "integration_points": self._analyze_integrations(documents),
            "critical_paths": self._identify_critical_implementation_paths(documents),
            "quality_gaps": self._assess_implementation_gaps(documents)
        }
        return analysis_result
    
    def _analyze_backend_implementation(self, documents):
        """Backend구현 분석"""
        return {
            "api_endpoints": self._extract_api_implementations(),
            "business_logic": self._extract_business_logic_implementations(),
            "data_models": self._extract_data_model_implementations(),
            "external_dependencies": self._extract_external_implementations(),
            "security_features": self._extract_security_implementations()
        }
    
    def _analyze_frontend_implementation(self, documents):
        """Frontend구현 분석"""
        return {
            "components": self._extract_component_implementations(),
            "pages": self._extract_page_implementations(),
            "user_flows": self._extract_user_flow_implementations(),
            "state_management": self._extract_state_implementations(),
            "api_integrations": self._extract_api_integration_implementations()
        }
```

### 4.2 기능별 구현 계획 수립

#### 4.2.1 구현 대상 기능 매핑 예시
```markdown
# 시스템 분석 결과 예시

## Backend기능 목록
### 인증/인가 기능
- **Level 1 대상**: JWT 토큰 생성, 비밀번호 해싱
- **Level 2 대상**: 로그인 API + DB 연동, 권한 체크
- **Level 3 대상**: 전체 인증 플로우, 세션 관리

### 사용자 관리 기능
- **Level 1 대상**: 사용자 생성/수정 시 유효성 검사
- **Level 2 대상**: 사용자 CRUD API + DB 연동, 이메일 전송
- **Level 3 대상**: 가입부터 인증 완료까지 전 흐름

### 데이터 처리 기능
- **Level 1 대상**: 계산 로직, 변환 로직
- **Level 2 대상**: 파일 업로드 + 스토리지 연동
- **Level 3 대상**: 배치 처리 파이프라인 구현

## Frontend기능 목록
### 인증 UI
- **Level 1 대상**: 로그인 폼 컴포넌트, 입력 검증
- **Level 2 대상**: 인증 상태 관리, API 연동
- **Level 3 대상**: 로그인 → 대시보드 흐름 전체 구현

### 사용자 관리 UI
- **Level 1 대상**: 사용자 리스트/상세 컴포넌트
- **Level 2 대상**: CRUD 조작 + API 연동, 상태 동기화
- **Level 3 대상**: 사용자 관리 전체 플로우

### 데이터 시각화 기능
- **Level 1 대상**: 차트/테이블 컴포넌트 구현
- **Level 2 대상**: 데이터 가져오기/업데이트, 필터 처리
- **Level 3 대상**: 대시보드 전반의 상호작용 구현
```

#### 4.2.2 레벨별 구현 계획 생성
```python
class ImplementationPlanGenerator:
    def generate_level_plans(self, analysis_result):
        """분석 결과 기반으로 레벨별 구현 계획 생성"""
        plans = {}
        
        for level in [1, 2, 3]:
            plans[f"level_{level}"] = {
                "backend": self._generate_backend_implementation_plan(analysis_result, level),
                "frontend": self._generate_frontend_implementation_plan(analysis_result, level),
                "estimated_time": self._estimate_implementation_time(analysis_result, level),
                "dependencies": self._identify_implementation_dependencies(analysis_result, level),
                "risks": self._assess_implementation_risks(analysis_result, level)
            }
        
        return plans
    
    def _generate_backend_implementation_plan(self, analysis, level):
        """Backend레벨별 구현 계획 생성"""
        if level == 1:
            return {
                "implementation_targets": analysis["backend_features"]["business_logic"],
                "mock_dependencies": analysis["backend_features"]["external_dependencies"],
                "implementation_count_estimate": len(analysis["backend_features"]["business_logic"]) * 3
            }
        elif level == 2:
            return {
                "implementation_targets": analysis["integration_points"]["api_database"],
                "real_dependencies": ["database", "development_services"],
                "implementation_count_estimate": len(analysis["integration_points"]["api_database"]) * 2
            }
        # Level 3의 경우는 별도 구현...
```

### 4.3 사용자 확인 및 선택 단계

#### 4.3.1 구현 계획 제시 포맷
```markdown
# 구현 실행 계획 (사용자 확인용)

## 시스템 분석 결과 요약
- **백엔드 기능 수**: 15개
- **프론트엔드 기능 수**: 12개
- **중요 기능 수**: 8개
- **외부 연동 수**: 5개 서비스

## 레벨별 실행 계획

### Level 1 (Backend + Frontend Unit구현)
**예상 소요 시간**: 2~3일
**구현 건수**: Backend 45건, Frontend 36건
**핵심 대상 기능**:
- ✅ 인증 로직 (Backend: JWT 생성, Frontend: 로그인 폼)
- ✅ 사용자 관리 (Backend: 검증 로직, Frontend: 리스트 출력)
- ✅ 데이터 처리 (Backend: 계산 로직, Frontend: 차트 출력)

**필요 환경**: 개발 환경만 필요
**리스크**: 낮음

### Level 2 (Backend + Frontend통합 구현)  
**예상 소요 시간**: 3~5일
**구현 건수**: Backend 30건, Frontend 24건
**핵심 대상 기능**:
- ✅ API + DB 연동 구현
- ✅ 외부 서비스 연동 (개발 환경 기준)
- ✅ 프론트엔드 상태관리 + API 연동

**필요 환경**: 개발 DB, 개발용 외부 서비스
**리스크**: 중간

### Level 3 (Backend + Frontend E2E구현)
**예상 소요 시간**: 5~7일
**구현 건수**: Backend 20건, Frontend 15건
**핵심 대상 기능**:
- ✅ 전체 사용자 흐름
- ✅ 성능 최적화
- ✅ 보안 강화 구현

**필요 환경**: 스테이징 환경
**리스크**: 높음

## 권장 실행 순서
1. **Level 1부터 시작** → 기초 품질 확보
2. **Level 2로 통합 테스트** → 서비스 연동 확인
3. **Level 3로 최종 검증** → 릴리스 직전 확인

## 사용자 선택 옵션
- `"Level 1만 실행"` → 개발 초기 품질 확보용
- `"Level 1-2실행"` → 통합 품질 검증용
- `"모든 레벨 실행"` → 전체 품질 확보 및 릴리스 전 점검
- `"사용자 정의 선택"` → 특정 기능 + 레벨 조합 실행
```

## 5. 구현 실행 플로우

### 5.1 단계별 실행 전략

#### Level 1 실행 플로우
```mermaid
graph TD
    A[구현 코드 분석] --> B[Backend Level 1 생성]
    A --> C[Frontend Level 1 생성]
    B --> D[Backend Unit 구현 실행]
    C --> E[Frontend Unit 구현 실행]
    D --> F[Level 1 통합 리포트 생성]
    E --> F
    F --> G[Level 2 실행 여부 판단]
```

#### Level 2 실행 플로우
```mermaid
graph TD
    A[Level 1 성공 여부 확인] --> B[Backend Level 2 생성]
    A --> C[Frontend Level 2 생성]
    B --> D[Backend 통합 구현 실행]
    C --> E[Frontend 통합 구현 실행]
    D --> F[Level 2 통합 리포트 생성]
    E --> F
    F --> G[Level 3 실행 여부 판단]
```

#### Level 3 실행 플로우
```mermaid
graph TD
    A[Level 2 성공 여부 확인] --> B[Backend Level 3 생성]
    A --> C[Frontend Level 3 생성]
    B --> D[Backend E2E 구현 실행]
    C --> E[Frontend E2E 구현 실행]
    D --> F[Level 3 통합 리포트 생성]
    E --> F
    F --> G[최종 종합 품질 평가]
```

## 6. 구현 케이스 설계 방침

### 6.1 Level 1 구현 케이스 설계

#### Backend Level 1
```python
class BackendLevel1Categories:
    BUSINESS_LOGIC = {
        "calculation_functions": "계산/변환 처리 로직 구현",
        "validation_logic": "입력값 유효성 검사 로직 구현", 
        "data_transformation": "데이터 변환 처리 로직 구현"
    }
    
    API_HANDLERS = {
        "request_processing": "요청 처리 로직 구현 (Mock 기반)",
        "response_formatting": "응답 데이터 포맷 구성 로직 구현",
        "error_handling": "에러 핸들링 처리 로직 구현"
    }
    
    SERVICE_METHODS = {
        "service_logic": "서비스 메서드 단위 구현",
        "state_transitions": "상태 전이 로직 구현",
        "business_rules": "비즈니스 규칙 처리 로직 구현"
    }
```

#### Frontend Level 1
```typescript
class FrontendLevel1Categories {
  COMPONENT_RENDERING = {
    "basic_rendering": "기본 렌더링 구현",
    "props_handling": "props처리 로직 구현",
    "conditional_rendering": "조건부 렌더링 구현"
  }
  
  EVENT_HANDLING = {
    "click_events": "클릭 이벤트 처리 구현",
    "form_submission": "폼 제출 처리 구현",
    "input_validation": "입력값 유효성 검사 구현"
  }
  
  CUSTOM_HOOKS = {
    "state_management": "상태 관리용 커스텀 훅 구현",
    "data_fetching": "데이터 요청용 커스텀 훅 구현 (Mock API 활용)",
    "side_effects": "사이드 이펙트 처리 로직 구현"
  }
}
```

### 6.2 Level 2 구현 케이스 설계

#### Backend Level 2
```python
class BackendLevel2Categories:
    API_DATABASE = {
        "crud_operations": "CRUD연산 전체 구현",
        "transaction_management": "트랜잭션 처리 구현",
        "constraint_validation": "DB제약 조건 검증 로직 구현"
    }
    
    SERVICE_INTEGRATION = {
        "service_chaining": "서비스 간 연동 처리 구현",
        "async_processing": "비동기 처리 로직 구현",
        "event_handling": "이벤트 기반 처리 로직 구현"
    }
    
    EXTERNAL_API = {
        "third_party_integration": "외부 API 연동 처리 구현 (개발환경 기준)",
        "authentication": "인증 플로우 구현",
        "rate_limiting": "API 호출 제한(rate limit) 처리 구현"
    }
```

#### Frontend Level 2
```typescript
class FrontendLevel2Categories {
  COMPONENT_INTEGRATION = {
    "parent_child_communication": "부모-자식 컴포넌트 연동 구현",
    "sibling_communication": "형제 컴포넌트 간 상태 공유 구현",
    "context_providers": "Context Provider기능 구현"
  }
  
  API_INTEGRATION = {
    "data_fetching": "API 기반 데이터 요청 및 수신 구현",
    "error_handling": "API 에러 핸들링 로직 구현",
    "loading_states": "로딩 상태 표시 및 전환 처리 구현"
  }
  
  STATE_MANAGEMENT = {
    "zustand_integration": "Zustand 상태 관리 적용",
    "local_storage": "로컬 스토리지 연동 처리",
    "routing": "라우팅 기능 구현 (예: React Router)"
  }
}
```

### 6.3 Level 3 구현 케이스 설계

#### Backend Level 3
```python
class BackendLevel3Categories:
    COMPLETE_WORKFLOWS = {
        "user_registration": "사용자 가입 전체 플로우 구현",
        "data_processing": "데이터 처리 파이프라인 구현",
        "report_generation": "리포트 생성 로직 구현"
    }
    
    PERFORMANCE = {
        "optimization": "성능 최적화 구현",
        "caching": "캐시 전략 적용",
        "scalability": "확장성 대응 로직 구현"
    }
    
    SECURITY = {
        "authentication_flow": "인증/인가 플로우 구현",
        "data_protection": "데이터 보호 로직 적용",
        "input_sanitization": "입력값 정제 처리 구현"
    }
```

#### Frontend Level 3
```typescript
class FrontendLevel3Categories {
  USER_JOURNEYS = {
    "registration_flow": "회원가입 사용자 플로우 구현",
    "login_logout": "로그인/로그아웃 기능 구현",
    "data_crud_flow": "데이터 생성/조회/수정/삭제 전체 흐름 구현"
  }
  
  CROSS_BROWSER = {
    "chrome_optimization": "Chrome 환경 최적화",
    "firefox_optimization": "Firefox 환경 최적화",
    "safari_optimization": "Safari 환경 최적화"
  }
  
  ACCESSIBILITY = {
    "aria_implementation": "ARIA 속성 적용",
    "keyboard_navigation": "키보드 네비게이션 지원 구현",
    "responsive_design": "반응형 UI 디자인 구현"
  }
}
```

## 7. 품질기준 (레벨 및 영역별)

### 7.1 Backend품질기준

| Level | 구현완성도목표 | 품질기준 | 구현시간제한 | 주요품질지표 |
|----|---|---|----|----|
| Backend L1 | 90%+ | 95%+ 동작확인률 | 각 구현 < 1시간 | 로직 정확도 및 일관성 |
| Backend L2 | 80%+ | 90%+ 동작확인률 | 각 구현 < 1일 | 모듈 간 연동 안정성 |
| Backend L3 | 70%+ | 85%+ 동작확인률 | 각 구현 < 1주일 | 전체 시스템 안정성 및 성능 |

### 7.2 Frontend품질기준

| Level | 구현완성도목표 | 품질기준 | 구현시간제한 | 주요품질지표 |
|----|---|---|----|----|
| Frontend L1 | 85%+ | 95%+ 동작확인률 | 각 구현 < 1시간 | UI 시각적 일관성과 정확성 |
| Frontend L2 | 75%+ | 90%+ 동작확인률 | 각 구현 < 1일 | UX 흐름의 자연스러움 및 반응성 |
| Frontend L3 | 70%+ | 85%+ 동작확인률 | 각 구현 < 1주일 | 실제 사용자 관점의 경험 품질 및 접근성 |

### 7.3 통합 품질 지표

#### 시스템 전체 신뢰도 산출 방식
```python
def calculate_system_implementation_quality():
    # Backend가중치
    backend_l1_weight = 0.25  # Backend기반 품질
    backend_l2_weight = 0.20  # Backend통합 품질
    backend_l3_weight = 0.15  # Backend E2E품질
    
    # Frontend가중치
    frontend_l1_weight = 0.20  # Frontend기반 품질
    frontend_l2_weight = 0.15  # Frontend통합 품질
    frontend_l3_weight = 0.05  # Frontend E2E품질
    
    total_quality = (
        backend_l1_quality * backend_l1_weight +
        backend_l2_quality * backend_l2_weight +
        backend_l3_quality * backend_l3_weight +
        frontend_l1_quality * frontend_l1_weight +
        frontend_l2_quality * frontend_l2_weight +
        frontend_l3_quality * frontend_l3_weight
    )
    
    return total_quality
```

## 8. 실행 일정

### 8.1 개발 단계별 실행 계획

#### Phase 1: Level 1 기반 구축（Week 1-2）
```yaml
backend_level1:
  - FastAPI환경 설정
  - Mock 기능 구현
  - 유닛 구현용 테스트 스위트 작성

frontend_level1:
  - Next.js + TypeScript개발 환경 구축
  - 컴포넌트 구현 작성
  - 커스텀 훅 구현
```

#### Phase 2: Level 2 통합 구축（Week 3-4）
```yaml
backend_level2:
  - 개발용 DB 환경 구축
  - 통합 구현용 테스트 스위트 작성
  - 개발용 데이터 관리 로직 구성

frontend_level2:
  - API 연동 개발 환경 구축
  - API 통합 구현 작성
  - 상태 관리(Zustand 등) 구현
```

#### Phase 3: Level 3 E2E구축（Week 5-6）
```yaml
backend_level3:
  - 스테이징 환경 구축
  - E2E 테스트 스위트 작성
  - 성능 개선용 구현 (캐싱 등)

frontend_level3:
  - 실서비스 유사 환경 구성
  - 전체 사용자 여정(User Journey) 흐름 구현
  - 접근성(Accessibility) 구현
```

### 8.2 지속적 실행 스케줄

#### 일일 실행 (Daily)
- Backend Level 1: 모든 유닛 단위 구현 실행 (단위 기능별 테스트 포함)
- Frontend Level 1: 전체 컴포넌트 구현 실행 (렌더링/이벤트 단위 검증 포함)

#### 주간 실행 (Weekly)
- Backend Level 2: 통합 구현 스위트 실행 (서비스 체이닝, 트랜잭션 포함)
- Frontend Level 2: API 연동 및 상태 관리(Zustand 등) 구현 실행

#### 릴리스 전 실행 (Pre-Release)
- Backend Level 3: 전체 End-to-End(E2E) 구현 및 검증 실행
- Frontend Level 3: 전체 사용자 여정(User Journey) 기반 흐름 검증 실행
- 전체 레벨 통합: 종합 품질 점검 수행 (테스트 커버리지, 성능, 보안 포함)

## 9. 실행 지시 형식 (Execution Prompt Format)

### 9.1 레벨 및 영역별 실행 지시

#### Backend전용 실행
```
"Backend Level 1에서 구현 생성"
"Backend Level 2에서 구현 생성"
"Backend Level 3에서 구현 생성"
```

#### Frontend전용 실행
```
"Frontend Level 1에서 구현 생성"
"Frontend Level 2에서 구현 생성"
"Frontend Level 3에서 구현 생성"
```

#### 레벨별 풀스택 실행 (백엔드 + 프론트 동시)
```
"Level 1에서 완전 구현 생성"  // Backend + Frontend Level 1
"Level 2에서 완전 구현 생성"  // Backend + Frontend Level 2
"Level 3에서 완전 구현 생성"  // Backend + Frontend Level 3
```

#### 전체 풀스택 실행
```
"전체 스택 구현 생성"     // 모든 Level + 모든 영역 한 번에 실행
"모든 레벨에서 구현 생성"       // Level 1 → 2 → 3 순차적으로 전체 실행
```

### 9.2 맞춤형 실행 지시 (Custom Execution Prompt)

#### 특정 조합 실행
```
"Backend Level 1-2 + Frontend Level 1에서 구현 생성"
"Backend Level 3 + Frontend Level 1-2에서 구현 생성"
```

## 10. 리포트 생성 요건

### 10.1 레벨・영역별 리포트 출력 방식

#### 개별 리포트 (레벨·영역 단위 상세 리포트)
- Backend Level 1 Report
- Frontend Level 1 Report
- Backend Level 2 Report
- Frontend Level 2 Report
- Backend Level 3 Report
- Frontend Level 3 Report

#### 통합 리포트 (레벨별 백엔드+프론트 통합 요약)
- Level 1 Complete Report (Backend + Frontend)
- Level 2 Complete Report (Backend + Frontend)
- Level 3 Complete Report (Backend + Frontend)
- Full Stack Summary Report

### 10.2 품질 대시보드

```markdown
# 풀스택 품질 대시보드

## 요약
| 영역 | Level 1 | Level 2 | Level 3 | 종합 |
|---|---|---|---|---|
| Backend | ✅ 95% | ✅ 88% | ⚠️ 82% | 88% |
| Frontend | ✅ 92% | ✅ 85% | ❌ 65% | 81% |
| **시스템 전체** | **93%** | **87%** | **74%** | **85%** |

## 권장 개선 액션
1. Frontend Level 3 구현 품질 향상
2. Backend Level 3 구현 시간 단축 
3. 통합 구현 케이스 추가 (Backend/Frontend 간 연동 강화)
```

## 11. 실제 실행 절차

### 11.1 Phase 0: 시스템 분석 개시

#### Step 1: 문서 제공
아래 문서를 시스템 분석을 위해 제공해 주세요：

**필수 문서 (Must)**:
- 구현 코드（Backend/Frontend）
- API명세서（OpenAPI/Swagger등）
- 데이터베이스 설계 문서（ERD、DDL등）

**권장 문서 (Optional)**:
- 시스템 아키텍처 설계서
- 요구사항 명세서
- 기존 소스코드 (기준선이 있다면)

#### Step 2: 자동 분석 실행
```
"시스템 분석을 실행해 주세요"
```
→ 모든 문서를 분석하여 구현할 기능을 식별합니다.

#### Step 3: 구현 계획 확정
분석 결과를 바탕으로 레벨별 구현 계획 제시
→ 사용자가 실시 레벨을 선택

### 11.2 Phase 1: 구현 생성 및 실행

#### 사용자가 선택한 범위에 따라 구현 생성
```
"Level 1에서 실행"
"Level 1-2에서 실행"  
"Backend Level 2만 실행"
"인증 기능만 Level 1-3까지 실행"
```

### 11.3 실행 지시 예시

#### 단계별 분석 및 실행 지시
```bash
# Step 1: 시스템 분석 요청
"시스템 분석을 실행해 주세요"

# Step 2: 분석 결과 확인 후, 원하는 실행 레벨 선택
"Level 1에서 실행해 주세요"
"Level 2까지 실행해 주세요"
"모든 레벨에서 실행해 주세요"

# Step 3: 맞춤 실행 요청 (기능 단위 실행)
"인증 기능과 사용자 관리 기능만 Level 1-2에서 실행해 주세요"
"Backend Level 1-3 + Frontend Level 1-2에서 실행해 주세요"
```

---

**이제 시스템 분석을 시작할 수 있습니다. 백엔드/프론트엔드의 구현 코드, API 명세서(OpenAPI/Swagger), DB 설계 문서(ERD/DDL 등)를 공유해 주시면 전체 시스템을 자동으로 분석하고, 구현이 필요한 기능과 그에 따른 단계별 실행 계획을 제안해 드립니다.**